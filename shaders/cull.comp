#version 460
#include <common.glsl>

layout (local_size_x = 256) in;

struct IndirectDrawCommand {
    uint indexCount;
    uint instanceCount;
    uint firstIndex;
    int vertexOffset;
    uint firstInstance;

    uint batchCount;

    uint padding0;
    uint padding1;
};

struct Mesh {
    vec3 bounds_max;
    uint firstIndex;
    vec3 bounds_min;
    uint indexCount;
    int vertexOffset;
};

layout(std140, set = 1, binding = 0) readonly buffer MeshesBuffer {
    Mesh meshes[];
} meshesBuffer;

layout(std140, set = 1, binding = 1) buffer IndirectBuffer {
	IndirectDrawCommand commands[];
} indirectBuffer;

void main() {
	uint gID = gl_GlobalInvocationID.x;
    if (gID >= globalUniform.renderablesCount) return;
    Object object = objectBuffer.objects[gID];
    Mesh mesh = meshesBuffer.meshes[object.mesh];

    uint batch = object.batch;
    bool visible = true;
    if (visible) {
        indirectBuffer.commands[batch].indexCount = mesh.indexCount;
        uint objectSlot = atomicAdd(indirectBuffer.commands[batch].instanceCount, 1);
        indirectBuffer.commands[batch].firstIndex = mesh.firstIndex;
        indirectBuffer.commands[batch].vertexOffset = mesh.vertexOffset;
        indirectBuffer.commands[batch].firstInstance = objectBuffer.objects[batch].firstInstance;
        indirectBuffer.commands[batch].batchCount = 1;

        objectBuffer.objects[objectBuffer.objects[batch].firstInstance +  objectSlot].redirect = gID;
    }
}
